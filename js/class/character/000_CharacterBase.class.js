// Generated by CoffeeScript 2.2.2
var CharacterBase;

CharacterBase = (function() {
  class CharacterBase extends ObjectBase {
    constructor(params) {
      super(ObjectBase.OBJECT_TYPE.CHARACTER);
      // 既に所有しているキャラクターであるか
      if (params.joined === null) {
        this.joined = this.constructor.defaultJoin;
      } else {
        this.joined = params.joined;
      }
      // 現在のレベル
      this.level = params.level;
      // 現在のHP
      this.hp = params.hp;
      // 装備しているアイテム
      this.items = params.items;
      // 出撃中であるか
      this.inField = params.inField;
      // 行動済みであるか
      this.moved = params.moved;
      // アイテム装備可能数
      this.itemCapacityPlus = params.itemCapacityPlus;
      // 装備中のアイテム
      this.items = params.items;
      // 復帰までに必要なターン
      this.comebackTurn = params.comebackTurn;
    }

    getId() {
      return this.constructor.characterId;
    }

    getName() {
      return this.constructor.characterName;
    }

    getHpMaxItemFixRate() {
      var i, itemObject, len, level, ref, res;
      res = 1;
      ref = this.items;
      for (i = 0, len = ref.length; i < len; i++) {
        [itemObject, level] = ref[i];
        res += itemObject.getHpFixRate();
      }
      return res;
    }

    getAttackItemFixRate() {
      var i, itemObject, len, level, ref, res;
      res = 1;
      ref = this.items;
      for (i = 0, len = ref.length; i < len; i++) {
        [itemObject, level] = ref[i];
        res += itemObject.getAttackFixRate();
      }
      return res;
    }

    getPDefItemFixRate() {
      var i, itemObject, len, level, ref, res;
      res = 1;
      ref = this.items;
      for (i = 0, len = ref.length; i < len; i++) {
        [itemObject, level] = ref[i];
        res += itemObject.getPDefRateFixRate();
      }
      return res;
    }

    getMDefItemFixRate() {
      var i, itemObject, len, level, ref, res;
      res = 1;
      ref = this.items;
      for (i = 0, len = ref.length; i < len; i++) {
        [itemObject, level] = ref[i];
        res += itemObject.getMDefRateFixRate();
      }
      return res;
    }

    getCostItemFixRate() {
      var i, itemObject, len, level, ref, res;
      res = 1;
      ref = this.items;
      for (i = 0, len = ref.length; i < len; i++) {
        [itemObject, level] = ref[i];
        res += itemObject.getCostRateFixRate();
      }
      return res;
    }

    getMoveItemFix() {
      var i, itemObject, len, level, ref, res;
      res = 0;
      ref = this.items;
      for (i = 0, len = ref.length; i < len; i++) {
        [itemObject, level] = ref[i];
        res += itemObject.getMoveFixPlus();
      }
      return res;
    }

    getRangeItemFix() {
      var i, itemObject, len, level, ref, res;
      res = 0;
      ref = this.items;
      for (i = 0, len = ref.length; i < len; i++) {
        [itemObject, level] = ref[i];
        res += itemObject.getRangeFixPlus();
      }
      return res;
    }

    getHitRateItemFix() {
      var i, itemObject, len, level, ref, res;
      res = 0;
      ref = this.items;
      for (i = 0, len = ref.length; i < len; i++) {
        [itemObject, level] = ref[i];
        res += itemObject.getHitFixPlus();
      }
      return res;
    }

    getDodgeRateItemFix() {
      var i, itemObject, len, level, ref, res;
      res = 0;
      ref = this.items;
      for (i = 0, len = ref.length; i < len; i++) {
        [itemObject, level] = ref[i];
        res += itemObject.getDodgeFixPlus();
      }
      return res;
    }

    getComebackItemFix() {
      var i, itemObject, len, level, ref, res;
      res = 0;
      ref = this.items;
      for (i = 0, len = ref.length; i < len; i++) {
        [itemObject, level] = ref[i];
        res += itemObject.getReturnFixPlus();
      }
      return res;
    }

    isInField() {
      return this.inField;
    }

    setInField(isInField) {
      this.inField = !!isInField;
      return CharacterPalletManager.redraw(this);
    }

    isMoved() {
      return this.moved;
    }

    setMoved(bool) {
      return this.moved = !!bool;
    }

    // 出撃可能か
    canPick() {
      return this.getComebackTurn <= 0 && !this.isInField();
    }

    getTextOnDeath() {
      return this.constructor.textDeath;
    }

    getCostBase() {
      return this.constructor.costBase;
    }

    getCost(level = null) {
      if (level === null) {
        return Math.ceil(this.constructor.costBase * this.level * this.getMDefItemFixRate());
      } else {
        return Math.ceil(this.constructor.costBase * level * this.getMDefItemFixRate());
      }
    }

    getComebackTurnStart() {
      return this.constructor.COMEBACK_TURN - this.getComebackItemFix();
    }

    getComebackTurn() {
      return this.comebackTurn;
    }

    setComebackTurn(comebackTurn) {
      this.comebackTurn = comebackTurn;
      return CharacterPalletManager.redraw(this);
    }

    decreaseComeback() {
      if (this.comebackTurn > 0) {
        this.comebackTurn--;
      }
      return CharacterPalletManager.redraw(this);
    }

    death() {
      this.setMoved(false);
      this.setInField(false);
      this.hp = null;
      return this.setComebackTurn(this.getComebackTurnStart());
    }

    // アイテム装備可能数（開始時）
    getItemCapacityStart() {
      return this.constructor.itemCapacityStart;
    }

    
    // アイテム装備可能数（開始時）
    getItemCapacityLimit() {
      return this.constructor.itemCapacityLimit;
    }

    
    // アイテム装備可能数
    getItemCapacity() {
      return this.getItemCapacityStart() + this.getItemCapacityPlus();
    }

    
    // アイテム装備可能数の加算値
    getItemCapacityPlus() {
      return this.itemCapacityPlus;
    }

    
    // アイテム装備可能数を増やす
    increaseItemCapacity(amount = 1) {
      this.itemCapacityPlus += amount;
      if (this.getItemCapacityLimit() - this.getItemCapacityStart() < this.itemCapacityPlus) {
        return this.itemCapacityPlus = this.getItemCapacityLimit() - this.getItemCapacityStart();
      }
    }

    
    // アイテム装備可能数を増やせるか
    canIncreaseItemCapacity(amount = 1) {
      return this.itemCapacityPlus + amount <= this.getItemCapacityLimit() - this.getItemCapacityStart();
    }

    // アイテムを装備
    setItem(itemObject, level) {
      return this.items.push([itemObject, level]);
    }

    // アイテムを外す
    dropItem(itemObject, level) {
      var deleted, i, iObj, items, len, lv, ref;
      items = [];
      deleted = false;
      ref = this.items;
      for (i = 0, len = ref.length; i < len; i++) {
        [iObj, lv] = ref[i];
        if (!deleted && iObj.getId() === itemObject.getId() && level === lv) {
          deleted = true;
        } else {
          items.push([iObj, lv]);
        }
      }
      this.items = items;
      return deleted;
    }

    dropAllItem() {
      return this.items = [];
    }

    // 装備中のアイテムを取得
    getItems() {
      this.items.sort(function(a, b) {
        var aItemObject, aLevel, bItemObject, bLevel;
        [aItemObject, aLevel] = a;
        [bItemObject, bLevel] = b;
        if (aItemObject.getDisplayOrder() < bItemObject.getDisplayOrder()) {
          return -1;
        }
        if (aItemObject.getDisplayOrder() > bItemObject.getDisplayOrder()) {
          return 1;
        }
        if (aLevel < bLevel) {
          return -1;
        }
        if (aLevel > bLevel) {
          return 1;
        }
        return 0;
      });
      return this.items;
    }

    // 装備中のアイテムのコストの合計を取得
    getItemCostTotal() {
      var i, itemObject, len, level, ref, total;
      total = 0;
      ref = this.items;
      for (i = 0, len = ref.length; i < len; i++) {
        [itemObject, level] = ref[i];
        total += itemObject.getCost(level);
      }
      return total;
    }

  };

  // 復帰までに必要なターン
  CharacterBase.COMEBACK_TURN = 5;

  return CharacterBase;

}).call(this);
